#!/usr/bin/env python

import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Self

Result = dict[str, list[str]]


@dataclass
class Column:
    name: str
    width: int

    @classmethod
    def new(cls, name: str) -> Self:
        return cls(name, len(name))

    def update(self, result: Result) -> None:
        width = max([len(line) for line in result[self.name]])
        self.width = max(self.width, width)

    def fill(self, s: str) -> str:
        return s * (self.width + 2)

    def format(self, result: Result, i: int) -> str:
        lines = result[self.name]
        s = lines[i] if i < len(lines) else ""
        return f" {s.ljust(self.width)} "


@dataclass(frozen=True)
class Schema:
    columns: list[Column]

    def pretty_print(self, results: list[Result]) -> None:
        for result in results:
            for column in self.columns:
                column.update(result)
        print(self.delim("┌", "┬", "┐"))
        print(self.row({column.name: [column.name] for column in self.columns}))
        for result in results:
            print(self.delim("├", "┼", "┤"))
            print(self.row(result))
        print(self.delim("└", "┴", "┘"))

    def delim(self, left: str, center: str, right: str) -> str:
        parts = [column.fill("─") for column in self.columns]
        return f"{left}{center.join(parts)}{right}"

    def row(self, result: Result) -> str:
        lines: list[str] = []
        max_lines = max([len(lines) for lines in result.values()])
        for i in range(max_lines):
            parts = [column.format(result, i) for column in self.columns]
            lines.append(f"│{'│'.join(parts)}│")
        return "\n".join(lines)


def main(args: list[str]) -> None:
    args = ["git"] + args

    results: list[Result] = []
    for path in get_repos():
        results.append(dict(repo=[str(path)], output=cmd(path, *args)))

    print(f"command: {' '.join(args)}")
    schema = Schema([Column.new("repo"), Column.new("output")])
    schema.pretty_print(results)


def get_repos() -> list[Path]:
    result: list[Path] = []
    for path in Path().rglob(".git"):
        if path.stat().st_size > 0:
            result.append(path.parent)
    return sorted(result)


def cmd(path: Path, *args: str) -> list[str]:
    result = subprocess.run(args, cwd=path, capture_output=True, text=True)
    if result.returncode != 0:
        raise Exception(f"{' '.join(args)} failed: {result.stderr}")
    return result.stdout.expandtabs().splitlines()


if __name__ == "__main__":
    main(sys.argv[1:])
