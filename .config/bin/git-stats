#!/usr/bin/env python

import os
from dataclasses import dataclass
from datetime import date as Date
from datetime import timedelta
from enum import StrEnum, auto
from pathlib import Path
from typing import Self

import click
import requests
from pydantic import AliasChoices, BaseModel, Field, field_serializer

REPOS: list[str] = [
    "render-markdown.nvim",
]


class Group(StrEnum):
    DAY = auto()
    WEEK = auto()
    MONTH = auto()
    QUARTER = auto()
    YEAR = auto()

    def start(self, date: Date) -> Date:
        if self == Group.DAY:
            return date
        elif self == Group.WEEK:
            return date - timedelta(days=date.weekday())
        elif self == Group.MONTH:
            return date - timedelta(days=date.day - 1)
        elif self == Group.QUARTER:
            quarter = (date.month - 1) // 3
            month = (quarter * 3) + 1
            return Date(date.year, month, 1)
        elif self == Group.YEAR:
            return Date(date.year, 1, 1)
        else:
            raise Exception(f"invalid group: {self}")


@dataclass(frozen=True)
class Stat(BaseModel):
    timestamp: Date
    count: int
    uniques: int

    def __lt__(self, other: Self) -> bool:
        assert self.timestamp == other.timestamp
        return self.count < other.count and self.uniques < other.uniques

    @field_serializer("timestamp")
    def serialize_timestamp(self, timestamp: Date) -> str:
        return timestamp.strftime("%Y-%m-%d")

    @staticmethod
    def new(timestamp: Date) -> "Stat":
        return Stat(timestamp=timestamp, count=0, uniques=0)


def get_dates(*data: list[Stat]) -> list[Date]:
    result: set[Date] = set()
    for stats in data:
        result.update(map(lambda stat: stat.timestamp, stats))
    return sorted(result)


def get_stat(stats: list[Stat], date: Date) -> Stat:
    for stat in stats:
        if stat.timestamp == date:
            return stat
    return Stat.new(date)


@dataclass(frozen=True)
class Traffic(BaseModel):
    count: int
    uniques: int
    stats: list[Stat] = Field(validation_alias=AliasChoices("clones", "views"))


@dataclass(frozen=True)
class GithubApi:
    endpoint: str
    owner: str
    token: str

    def traffic(self, name: str, kind: str) -> list[Stat]:
        # https://docs.github.com/en/rest/metrics/traffic?apiVersion=2022-11-28
        url = f"{self.endpoint}/repos/{self.owner}/{name}/traffic/{kind}"
        headers = {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {self.token}",
            "X-GitHub-Api-Version": "2022-11-28",
        }
        response = requests.get(url, headers=headers)
        assert response.status_code == 200, "auth token is likely expired"
        traffic = Traffic.model_validate(response.json())
        return traffic.stats

    @staticmethod
    def new() -> "GithubApi":
        return GithubApi(
            endpoint="https://api.github.com",
            owner="MeanderingProgrammer",
            token=env("GITHUB_TOKEN"),
        )


@dataclass(frozen=True)
class Repo(BaseModel):
    name: str
    clones: list[Stat]
    views: list[Stat]

    def union(self, other: Self) -> Self:
        assert self.name == other.name
        return type(self)(
            name=self.name,
            clones=Repo.join("clones", self.clones, other.clones),
            views=Repo.join("views", self.views, other.views),
        )

    @staticmethod
    def join(name: str, old: list[Stat], new: list[Stat]) -> list[Stat]:
        result: list[Stat] = []
        for date in get_dates(old, new):
            old_stat = get_stat(old, date)
            new_stat = get_stat(new, date)
            if old_stat < new_stat:
                print(f"{date} [{name}] {old_stat.uniques} -> {new_stat.uniques}")
                stat = new_stat
            else:
                stat = old_stat
            result.append(stat)
        return result


@dataclass(frozen=True)
class Repos(BaseModel):
    repos: list[Repo]

    def get(self, name: str) -> Repo:
        i = self.index(name)
        if i is not None:
            print(f"exists: {name}")
            return self.repos[i]
        else:
            print(f"new   : {name}")
            return Repo(name=name, clones=[], views=[])

    def set(self, repo: Repo) -> None:
        i = self.index(repo.name)
        if i is not None:
            self.repos[i] = repo
        else:
            self.repos.append(repo)

    def index(self, name: str) -> int | None:
        for i, repo in enumerate(self.repos):
            if repo.name == name:
                return i
        return None


@dataclass(frozen=True)
class TrafficCache:
    file: Path

    def read(self) -> Repos:
        if self.file.exists():
            return Repos.model_validate_json(self.file.read_text())
        else:
            return Repos(repos=[])

    def write(self, repos: Repos) -> None:
        self.file.write_text(repos.model_dump_json())

    def add(self, update: Repo) -> None:
        repos = self.read()
        repo = repos.get(update.name)
        repo = repo.union(update)
        repos.set(repo)
        self.write(repos)

    @staticmethod
    def new() -> "TrafficCache":
        return TrafficCache(
            file=Path(env("XDG_DATA_HOME")).joinpath("git-traffic.json"),
        )


@dataclass(frozen=True)
class Output:
    dates: list[Date]
    clones: list[int]
    views: list[int]

    def table(self) -> None:
        cols: list[list[str]] = [
            ["Date"] + [str(date) for date in self.dates],
            ["Clones"] + [f"{n:,}" for n in self.clones],
            ["Views"] + [f"{n:,}" for n in self.views],
        ]

        widths: list[int] = []
        for col in cols:
            widths.append(max([len(value) for value in col]))

        def separator(left: str, center: str, right: str) -> str:
            sections: list[str] = ["─" * (width + 2) for width in widths]
            return left + center.join(sections) + right

        lines: list[str] = []
        for i in range(len(self.dates) + 1):
            row: list[str] = []
            for col, width in zip(cols, widths):
                row.append(f"{col[i]:<{width}}")
            lines.append("│ " + " │ ".join(row) + " │")

        print(separator("┌", "┬", "┐"))
        print(lines.pop(0))
        print(separator("├", "┼", "┤"))
        for line in lines:
            print(line)
        print(separator("└", "┴", "┘"))

    def graph(self) -> None:
        def bar(color: int, values: list[int], i: int) -> str:
            value = values[i]
            scale = max(round(max(values) / 160), 1)
            n = round(value / scale)
            return f"\033[{color}m{'█' * n}\033[0m {value}"

        for i, date in enumerate(self.dates):
            label = str(date)
            print(f"{label} {bar(94, self.clones, i)}")
            space = " " * len(label)
            print(f"{space} {bar(91, self.views, i)}")

    @staticmethod
    def new(group: Group, repo: Repo) -> "Output":
        def group_by(stats: list[Stat]) -> list[Stat]:
            groups: dict[Date, Stat] = dict()
            for stat in stats:
                start = group.start(stat.timestamp)
                current = groups.get(start, Stat.new(start))
                groups[start] = Stat(
                    timestamp=start,
                    count=current.count + stat.count,
                    uniques=current.uniques + stat.uniques,
                )
            return list(groups.values())

        clones = group_by(repo.clones)
        views = group_by(repo.views)
        dates = get_dates(clones, views)
        return Output(
            dates=dates,
            clones=[get_stat(clones, date).uniques for date in dates],
            views=[get_stat(views, date).uniques for date in dates],
        )


def env(name: str) -> str:
    value = os.getenv(name)
    assert value is not None, f"undefined: {name}"
    return value


@click.group(
    context_settings=dict(
        help_option_names=["-h", "--help"],
    ),
    invoke_without_command=True,
)
@click.pass_context
def cli(ctx: click.Context) -> None:
    """GitHub repo statistics"""
    if ctx.invoked_subcommand is None:
        update()


@cli.command()
def update() -> None:
    """Update statistics from API"""
    api = GithubApi.new()
    cache = TrafficCache.new()
    for name in REPOS:
        repo = Repo(
            name=name,
            clones=api.traffic(name, "clones"),
            views=api.traffic(name, "views"),
        )
        cache.add(repo)


@cli.command()
@click.option(
    "-g",
    "--group",
    type=click.Choice(Group, case_sensitive=False),
    default=Group.WEEK,
    help="how to group statistics",
)
def graph(group: Group) -> None:
    """Output graph of statistics"""
    repos = TrafficCache.new().read()
    for name in REPOS:
        repo = repos.get(name)
        Output.new(group, repo).graph()


@cli.command()
@click.option(
    "-g",
    "--group",
    type=click.Choice(Group, case_sensitive=False),
    default=Group.WEEK,
    help="how to group statistics",
)
def table(group: Group) -> None:
    """Output table of statistics"""
    repos = TrafficCache.new().read()
    for name in REPOS:
        repo = repos.get(name)
        Output.new(group, repo).table()


if __name__ == "__main__":
    cli()
