#!/usr/bin/env python

import argparse
import os
from dataclasses import dataclass
from datetime import date
from pathlib import Path
from typing import Self

import requests
from pydantic import AliasChoices, BaseModel, Field, field_serializer


@dataclass(frozen=True)
class Stat(BaseModel):
    timestamp: date
    count: int
    uniques: int

    def __lt__(self, other: Self) -> bool:
        assert self.timestamp == other.timestamp
        return self.count < other.count and self.uniques < other.uniques

    @field_serializer("timestamp")
    def serialize_timestamp(self, timestamp: date) -> str:
        return timestamp.strftime("%Y-%m-%d")


@dataclass(frozen=True)
class Traffic(BaseModel):
    count: int
    uniques: int
    stats: list[Stat] = Field(validation_alias=AliasChoices("clones", "views"))


@dataclass(frozen=True)
class GithubApi:
    endpoint: str
    owner: str
    token: str

    def traffic(self, name: str, kind: str) -> list[Stat]:
        # https://docs.github.com/en/rest/metrics/traffic?apiVersion=2022-11-28
        url = f"{self.endpoint}/repos/{self.owner}/{name}/traffic/{kind}"
        headers = {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {self.token}",
            "X-GitHub-Api-Version": "2022-11-28",
        }
        response = requests.get(url, headers=headers)
        assert response.status_code == 200, "auth token is likely expired"
        traffic = Traffic.model_validate(response.json())
        return traffic.stats


@dataclass(frozen=True)
class Stats:
    stats: list[Stat]

    def get(self, timestamp: date) -> Stat:
        for stat in self.stats:
            if stat.timestamp == timestamp:
                return stat
        return Stat(timestamp=timestamp, count=0, uniques=0)

    def timestamps(self, other: Self) -> list[date]:
        result: set[date] = set()
        result.update(map(lambda stat: stat.timestamp, self.stats))
        result.update(map(lambda stat: stat.timestamp, other.stats))
        return sorted(result)

    def combine(self, other: Self) -> list[Stat]:
        result: list[Stat] = []
        for timestamp in self.timestamps(other):
            stat1 = self.get(timestamp)
            stat2 = other.get(timestamp)
            stat = stat2 if stat1 < stat2 else stat1
            result.append(stat)
        return result


@dataclass(frozen=True)
class Entry:
    timestamp: date
    clones: int
    views: int

    def __post_init__(self) -> None:
        assert self.clones < 100_000 and self.views < 10_000


@dataclass(frozen=True)
class Repo(BaseModel):
    name: str
    clones: list[Stat]
    views: list[Stat]

    def combine(self, other: Self) -> Self:
        assert self.name == other.name
        return type(self)(
            name=self.name,
            clones=Stats(self.clones).combine(Stats(other.clones)),
            views=Stats(self.views).combine(Stats(other.views)),
        )

    def uniques(self) -> list[Entry]:
        result: list[Entry] = []
        clones = Stats(self.clones)
        views = Stats(self.views)
        for timestamp in clones.timestamps(views):
            entry = Entry(
                timestamp=timestamp,
                clones=clones.get(timestamp).uniques,
                views=views.get(timestamp).uniques,
            )
            result.append(entry)
        return result

    def table(self) -> None:
        print(Repo.separator("┌", "┬", "┐"))
        print("│ Date       │ Clones │ Views │")
        print(Repo.separator("├", "┼", "┤"))
        for entry in self.uniques():
            parts: list[str] = [
                str(entry.timestamp),
                f"{entry.clones:<6,}",
                f"{entry.views:<5,}",
            ]
            print("│ " + " │ ".join(parts) + " │")
        print(Repo.separator("└", "┴", "┘"))

    def graph(self) -> None:
        for entry in self.uniques():
            label = str(entry.timestamp)
            print(f"{label} {Repo.bar(entry.clones, 100, 94)}")
            filler = " " * len(label)
            print(f"{filler} {Repo.bar(entry.views, 10, 91)}")

    @staticmethod
    def separator(left: str, center: str, right: str) -> str:
        widths: list[int] = [10, 6, 5]
        sections: list[str] = ["─" * (width + 2) for width in widths]
        return left + center.join(sections) + right

    @staticmethod
    def bar(amount: int, scale: int, color: int) -> str:
        n = round(amount / scale)
        assert n < 160
        return f"\033[{color}m{'█' * n}\033[0m {amount}"


@dataclass(frozen=True)
class Repos(BaseModel):
    repos: list[Repo]

    def get(self, name: str) -> Repo:
        i = self.index(name)
        if i is not None:
            print(f"exists: {name}")
            return self.repos[i]
        else:
            print(f"new   : {name}")
            return Repo(name=name, clones=[], views=[])

    def set(self, repo: Repo) -> None:
        i = self.index(repo.name)
        if i is not None:
            self.repos[i] = repo
        else:
            self.repos.append(repo)

    def index(self, name: str) -> int | None:
        for i, repo in enumerate(self.repos):
            if repo.name == name:
                return i
        return None


@dataclass(frozen=True)
class TrafficCache:
    file: Path

    def read(self) -> Repos:
        if self.file.exists():
            return Repos.model_validate_json(self.file.read_text())
        else:
            return Repos(repos=[])

    def write(self, repos: Repos) -> None:
        self.file.write_text(repos.model_dump_json())

    def add(self, update: Repo) -> None:
        repos = self.read()

        repo = repos.get(update.name)
        clones = len(repo.clones)
        views = len(repo.views)

        repo = repo.combine(update)
        print(f"clones: {clones} -> {len(repo.clones)}")
        print(f"views : {views} -> {len(repo.views)}")

        repos.set(repo)
        self.write(repos)


def main(table: bool, graph: bool) -> None:
    api = GithubApi(
        endpoint="https://api.github.com",
        owner="MeanderingProgrammer",
        token=env("GITHUB_TOKEN"),
    )
    cache = TrafficCache(
        file=Path(env("XDG_DATA_HOME")).joinpath("git-traffic.json"),
    )
    repos: list[str] = [
        "render-markdown.nvim",
    ]
    for name in repos:
        if table:
            cache.read().get(name).table()
        elif graph:
            cache.read().get(name).graph()
        else:
            repo = Repo(
                name=name,
                clones=api.traffic(name, "clones"),
                views=api.traffic(name, "views"),
            )
            cache.add(repo)


def env(name: str) -> str:
    value = os.getenv(name)
    assert value is not None, f"undefined: {name}"
    return value


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="GitHub repo statistics",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-t", "--table", action="store_true", help="Output table")
    group.add_argument("-g", "--graph", action="store_true", help="Output graph")
    args = parser.parse_args()
    main(args.table, args.graph)
