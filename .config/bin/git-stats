#!/usr/bin/env python

import os
from dataclasses import dataclass
from datetime import date, timedelta
from enum import StrEnum, auto
from pathlib import Path
from typing import Self

import click
import requests
from pydantic import AliasChoices, BaseModel, Field, field_serializer

REPOS: list[str] = [
    "render-markdown.nvim",
]


class Group(StrEnum):
    DAY = auto()
    WEEK = auto()
    MONTH = auto()
    QUARTER = auto()
    YEAR = auto()

    def start(self, timestamp: date) -> date:
        if self == Group.DAY:
            return timestamp
        elif self == Group.WEEK:
            return timestamp - timedelta(days=timestamp.weekday())
        elif self == Group.MONTH:
            return timestamp - timedelta(days=timestamp.day - 1)
        elif self == Group.QUARTER:
            quarter = (timestamp.month - 1) // 3
            month = (quarter * 3) + 1
            return date(timestamp.year, month, 1)
        elif self == Group.YEAR:
            return date(timestamp.year, 1, 1)
        else:
            raise Exception(f"invalid group: {self}")


@dataclass(frozen=True)
class Stat(BaseModel):
    timestamp: date
    count: int
    uniques: int

    def __lt__(self, other: Self) -> bool:
        assert self.timestamp == other.timestamp
        return self.count < other.count and self.uniques < other.uniques

    @field_serializer("timestamp")
    def serialize_timestamp(self, timestamp: date) -> str:
        return timestamp.strftime("%Y-%m-%d")

    @staticmethod
    def new(timestamp: date) -> "Stat":
        return Stat(timestamp=timestamp, count=0, uniques=0)


@dataclass(frozen=True)
class Traffic(BaseModel):
    count: int
    uniques: int
    stats: list[Stat] = Field(validation_alias=AliasChoices("clones", "views"))


@dataclass(frozen=True)
class GithubApi:
    endpoint: str
    owner: str
    token: str

    def traffic(self, name: str, kind: str) -> list[Stat]:
        # https://docs.github.com/en/rest/metrics/traffic?apiVersion=2022-11-28
        url = f"{self.endpoint}/repos/{self.owner}/{name}/traffic/{kind}"
        headers = {
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {self.token}",
            "X-GitHub-Api-Version": "2022-11-28",
        }
        response = requests.get(url, headers=headers)
        assert response.status_code == 200, "auth token is likely expired"
        traffic = Traffic.model_validate(response.json())
        return traffic.stats

    @staticmethod
    def new() -> "GithubApi":
        return GithubApi(
            endpoint="https://api.github.com",
            owner="MeanderingProgrammer",
            token=env("GITHUB_TOKEN"),
        )


@dataclass(frozen=True)
class Stats:
    name: str
    stats: list[Stat]

    def get(self, timestamp: date) -> Stat:
        for stat in self.stats:
            if stat.timestamp == timestamp:
                return stat
        return Stat.new(timestamp)

    def uniques(self, timestamps: list[date]) -> list[int]:
        result: list[int] = []
        for timestamp in timestamps:
            stat = self.get(timestamp)
            result.append(stat.uniques)
        return result

    def group(self, group: Group) -> Self:
        groups: dict[date, Stat] = dict()
        for stat in self.stats:
            start = group.start(stat.timestamp)
            current = groups.get(start, Stat.new(start))
            groups[start] = Stat(
                timestamp=start,
                count=current.count + stat.count,
                uniques=current.uniques + stat.uniques,
            )
        starts = sorted(groups.keys())
        stats = [groups[start] for start in starts]
        return type(self)(name=self.name, stats=stats)

    def union(self, other: Self) -> list[Stat]:
        assert self.name == other.name
        result: list[Stat] = []
        for timestamp in Stats.timestamps([self, other]):
            stat1 = self.get(timestamp)
            stat2 = other.get(timestamp)
            if stat1 < stat2:
                print(f"{timestamp} [{self.name}] {stat1.uniques} -> {stat2.uniques}")
                stat = stat2
            else:
                stat = stat1
            result.append(stat)
        return result

    @staticmethod
    def timestamps(data: list["Stats"]) -> list[date]:
        result: set[date] = set()
        for stats in data:
            result.update(map(lambda stat: stat.timestamp, stats.stats))
        return sorted(result)


@dataclass(frozen=True)
class Repo(BaseModel):
    name: str
    clones: list[Stat]
    views: list[Stat]

    def get_clones(self) -> Stats:
        return Stats("clones", self.clones)

    def get_views(self) -> Stats:
        return Stats("views", self.views)

    def union(self, other: Self) -> Self:
        assert self.name == other.name
        return type(self)(
            name=self.name,
            clones=self.get_clones().union(other.get_clones()),
            views=self.get_views().union(other.get_views()),
        )


@dataclass(frozen=True)
class Repos(BaseModel):
    repos: list[Repo]

    def get(self, name: str) -> Repo:
        i = self.index(name)
        if i is not None:
            print(f"exists: {name}")
            return self.repos[i]
        else:
            print(f"new   : {name}")
            return Repo(name=name, clones=[], views=[])

    def set(self, repo: Repo) -> None:
        i = self.index(repo.name)
        if i is not None:
            self.repos[i] = repo
        else:
            self.repos.append(repo)

    def index(self, name: str) -> int | None:
        for i, repo in enumerate(self.repos):
            if repo.name == name:
                return i
        return None


@dataclass(frozen=True)
class TrafficCache:
    file: Path

    def read(self) -> Repos:
        if self.file.exists():
            return Repos.model_validate_json(self.file.read_text())
        else:
            return Repos(repos=[])

    def write(self, repos: Repos) -> None:
        self.file.write_text(repos.model_dump_json())

    def add(self, update: Repo) -> None:
        repos = self.read()
        repo = repos.get(update.name)
        repo = repo.union(update)
        repos.set(repo)
        self.write(repos)

    @staticmethod
    def new() -> "TrafficCache":
        return TrafficCache(
            file=Path(env("XDG_DATA_HOME")).joinpath("git-traffic.json"),
        )


@dataclass(frozen=True)
class Output:
    group: Group
    repo: Repo

    def table(self) -> None:
        timestamps, clones, views = self.data()

        cols: list[list[str]] = [
            ["Date"] + [str(timestamp) for timestamp in timestamps],
            ["Clones"] + [f"{n:,}" for n in clones],
            ["Views"] + [f"{n:,}" for n in views],
        ]

        widths: list[int] = []
        for col in cols:
            widths.append(max([len(value) for value in col]))

        lines: list[str] = []
        for i in range(len(timestamps) + 1):
            row: list[str] = []
            for col, width in zip(cols, widths):
                row.append(f"{col[i]:<{width}}")
            lines.append("│ " + " │ ".join(row) + " │")

        def separator(left: str, center: str, right: str) -> str:
            sections: list[str] = ["─" * (width + 2) for width in widths]
            return left + center.join(sections) + right

        print(separator("┌", "┬", "┐"))
        print(lines.pop(0))
        print(separator("├", "┼", "┤"))
        for line in lines:
            print(line)
        print(separator("└", "┴", "┘"))

    def graph(self) -> None:
        timestamps, clones, views = self.data()

        def get_scale(values: list[int]) -> int:
            return max(round(max(values) / 160), 1)

        clone_scale, view_scale = get_scale(clones), get_scale(views)

        def bar(prefix: str, color: int, value: int, scale: int) -> str:
            n = round(value / scale)
            return f"{prefix} \033[{color}m{'█' * n}\033[0m {value}"

        for i, timestamp in enumerate(timestamps):
            label = str(timestamp)
            print(bar(label, 94, clones[i], clone_scale))
            filler = " " * len(label)
            print(bar(filler, 91, views[i], view_scale))

    def data(self) -> tuple[list[date], list[int], list[int]]:
        clones = self.repo.get_clones().group(self.group)
        views = self.repo.get_views().group(self.group)
        timestamps = Stats.timestamps([clones, views])
        return (
            timestamps,
            clones.uniques(timestamps),
            views.uniques(timestamps),
        )


def env(name: str) -> str:
    value = os.getenv(name)
    assert value is not None, f"undefined: {name}"
    return value


@click.group()
def cli() -> None:
    """GitHub repo statistics"""
    pass


@cli.command()
@click.option(
    "-g",
    "--group",
    type=click.Choice(Group, case_sensitive=False),
    default=Group.WEEK,
    help="how to group statistics",
)
def graph(group: Group) -> None:
    """Output graph of statistics"""
    repos = TrafficCache.new().read()
    for name in REPOS:
        repo = repos.get(name)
        Output(group, repo).graph()


@cli.command()
@click.option(
    "-g",
    "--group",
    type=click.Choice(Group, case_sensitive=False),
    default=Group.WEEK,
    help="how to group statistics",
)
def table(group: Group) -> None:
    """Output table of statistics"""
    repos = TrafficCache.new().read()
    for name in REPOS:
        repo = repos.get(name)
        Output(group, repo).table()


@cli.command()
def update() -> None:
    """Update statistics from API"""
    api = GithubApi.new()
    cache = TrafficCache.new()
    for name in REPOS:
        repo = Repo(
            name=name,
            clones=api.traffic(name, "clones"),
            views=api.traffic(name, "views"),
        )
        cache.add(repo)


if __name__ == "__main__":
    cli()
