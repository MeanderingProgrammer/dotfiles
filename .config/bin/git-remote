#!/usr/bin/env python

import os
import subprocess
from enum import StrEnum, auto
from pathlib import Path

import click
import git
import requests


class Remote(StrEnum):
    LAB = auto()
    BIT = auto()

    @property
    def url(self) -> str:
        match self:
            case Remote.LAB:
                return "git@gitlab.com"
            case Remote.BIT:
                return "git@bitbucket.org"

    @property
    def auto_creates(self) -> bool:
        match self:
            case Remote.LAB:
                return True
            case Remote.BIT:
                return False


@click.group()
@click.help_option("-h", "--help")
def cli() -> None:
    """Scripts to automate interacting with multiple remotes"""
    pass


@cli.command()
def sync() -> None:
    """Sync all repos to remotes"""
    repos = [git.Repo(Path.home() / ".local/share/yadm/repo.git")]
    repos.extend(get_repos(Path.home() / "Documents"))
    repos.extend(get_repos(Path.home() / "dev/repos/personal"))
    for repo in repos:
        push_remotes(repo)


@cli.command()
def push() -> None:
    """Push current repo to remotes"""
    push_remotes(git.Repo())


def get_repos(directory: Path) -> list[git.Repo]:
    result: list[git.Repo] = []
    for path in directory.rglob(".git"):
        if path.stat().st_size > 0:
            result.append(git.Repo(path.parent))
    return result


def push_remotes(repo: git.Repo) -> None:
    user_name = str(git.GitConfigParser().get_value("user", "name"))

    assert "origin" in repo.remotes, f"missing origin: {list(repo.remotes)}"
    origin = repo.remotes["origin"].url

    # "git@gh.com:user/aoc.nvim.git" -> "git@gh.com", "user/aoc.nvim.git"
    host, path = origin.split(":")
    assert host == "git@github.com", f"invalid host: {host}"

    # "user/aoc.nvim.git" -> "user", "aoc.nvim"
    owner, name = path.rsplit(".", 1)[0].split("/")
    if owner != user_name:
        print(f"skipping {name}: not owned by {user_name}")
        return

    if is_fork(owner, name):
        print(f"skipping {name}: fork")
        return

    for remote in Remote:
        url = f"{remote.url}:{path}"
        if str(remote) in repo.remotes:
            print(f"{remote} is already a remote")
            assert repo.remotes[str(remote)].url == url
        else:
            assert cmd(repo, "git", "remote", "add", str(remote), url)
            assert str(remote) in repo.remotes

    for remote in Remote:
        assert cmd(repo, "git", "push", str(remote))


def is_fork(owner: str, name: str) -> bool:
    token = os.getenv("GITHUB_TOKEN")
    assert token is not None, "GITHUB_TOKEN not set"
    result = requests.get(
        f"https://api.github.com/repos/{owner}/{name}",
        headers={"Authorization": f"token {token}"},
    )
    # assume 404 is caused by personal private repos
    if result.status_code == 404:
        return False
    assert result.status_code == 200, "GITHUB_TOKEN is likely expired"
    return result.json()["fork"]


def cmd(repo: git.Repo, *args: str) -> bool:
    # GitPython struggles with yadm so need to run some things directly
    print(f"running '{' '.join(args)}' in: {repo.git_dir}")
    result = subprocess.run(args, cwd=repo.git_dir)
    return result.returncode == 0


if __name__ == "__main__":
    cli()
