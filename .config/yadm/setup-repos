#!/usr/bin/env python

import subprocess
from dataclasses import dataclass, field
from functools import cache
from pathlib import Path

import git


@dataclass(frozen=True)
class Repo:
    name: str
    owner: str | None = None
    post_update: list[str] = field(default_factory=list)

    @property
    def ssh(self) -> str:
        owner: str = self.owner or get_user_name()
        return f"git@github.com:{owner}/{self.name}.git"

    def setup(self, root: Path) -> None:
        directory: Path = self.update(root)
        for command in self.post_update:
            Repo.run(directory, command)

    def update(self, root: Path) -> Path:
        path: Path = root.joinpath(self.name)
        if path.is_dir():
            Repo.update_existing_repo(path)
        else:
            print(f"Cloning {self.ssh} to {path}")
            repo: git.Repo = git.Repo.clone_from(self.ssh, path)
            Repo.update_submodules(repo)
        return path

    @staticmethod
    def update_existing_repo(path: Path) -> None:
        repo: git.Repo = git.Repo(path)
        changes: int = len(repo.index.diff(None)) + len(repo.untracked_files)
        local_commit: str = str(repo.head.commit)
        revision: str = f"{repo.remote().name}/{repo.active_branch.name}"
        merged_commit: str = str(repo.rev_parse(revision))
        if changes > 0:
            print(f"Found {changes} unstaged changes, not updating {path}")
        elif local_commit != merged_commit:
            print(f"Found unmerged commits, not updating {path}")
        else:
            print(f"Pulling: {path}")
            repo.remote().pull()
            Repo.update_submodules(repo)

    @staticmethod
    def update_submodules(repo: git.Repo) -> None:
        repo.git.submodule("update", "--init", "--recursive")

    @staticmethod
    def run(directory: Path, command: str) -> None:
        print(f"Runnning '{command}' in '{directory}'")
        result = subprocess.run(command.split(), cwd=directory)
        assert result.returncode == 0


@cache
def get_user_name() -> str:
    return str(git.GitConfigParser().get_value("user", "name"))


@dataclass(frozen=True)
class RepoRoot:
    root: Path
    repos: list[Repo]

    def setup(self) -> None:
        if not self.root.is_dir():
            print(f"Creating: {self.root}")
            self.root.mkdir(parents=True)
        [repo.setup(self.root) for repo in self.repos]


def main() -> None:
    document_root = RepoRoot(
        root=Path.home().joinpath("Documents"),
        repos=[
            Repo(name="notes"),
            Repo(name="pass"),
        ],
    )
    personal_root = RepoRoot(
        root=Path.home().joinpath("dev/repos/personal"),
        repos=[
            Repo(name="advent-of-code"),
            Repo(name="chess"),
            Repo(name="cli", post_update=["just install"]),
            Repo(name="dashboard.nvim"),
            Repo(name="debug-it"),
            Repo(name="harpoon-core.nvim"),
            Repo(name="learning"),
            Repo(name="markdown.nvim"),
            Repo(name="pass-yank", post_update=["just install"]),
            Repo(name="py-requirements.nvim"),
            Repo(name="resume"),
            Repo(name="small-apps"),
        ],
    )
    open_source_root = RepoRoot(
        root=Path.home().joinpath("dev/repos/open-source"),
        repos=[Repo(owner="kdheepak", name="panvimdoc")],
    )
    plugin_root = RepoRoot(
        root=Path.home().joinpath("dev/repos/open-source/nvim-plugins"),
        repos=[
            Repo(owner="Saecki", name="crates.nvim"),
            Repo(owner="ThePrimeagen", name="harpoon"),
        ],
    )
    repo_roots: list[RepoRoot] = [
        document_root,
        personal_root,
        open_source_root,
        plugin_root,
    ]
    [repo_root.setup() for repo_root in repo_roots]


if __name__ == "__main__":
    main()
